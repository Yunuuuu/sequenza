%\VignetteIndexEntry{sequenza usage example}
%\VignetteDepends{sequenza}
%\VignetteKeywords{LOH}
%\VignetteKeywords{Heterogenity}
%\VignetteKeywords{Cancer sequencing}
%\VignettePackage{sequenza}

\documentclass[12pt]{article}
\usepackage{hyperref}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{float}

\newcommand{\shellcmd}[1]{\\\indent\indent\texttt{\footnotesize\# #1}\\}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\textwidth=6.2in
\textheight=8.5in
\oddsidemargin=0.2in
\evensidemargin=0.2in
\headheight=0in
\headsep=0in

\author{Francesco Favero\footnote{favero@cbs.dtu.dk}, Aron C. Eklund}

\begin{document}
\SweaveOpts{concordance=TRUE}
\title{sequenza usage example}
\maketitle

\tableofcontents

\section{Abstract}
Deep sequence of tumor DNA along with corresponding normal DNA can provide a rich picture of the mutations and aberrations that characterize the tumor. However, analysis of this data can be impeded by of tumor cellularity and heterogeneity and by unwieldy data. Here we describe the \textit{sequenza} software system, which comprises a fast python-based pre-processor and an R-based analysis package. Sequenza enables the efficient estimation of tumor cellularity and ploidy, and generation of copy number, loss-of-heterozygosity, and mutation frequency profiles. 

This document details a typical analysis of matched tumor-normal exome sequence data using \textit{sequenza}.

\section{Minimum requirements}
\begin{itemize}
\item Software: R, Python
\item Operating system: Linux, OSX
\item Memory: Minimum 4GB of RAM.  Recommended >8GB.
\item Disk space: 1.5 GB for each sample 
\item R version: 2.15.1 
\item Python version: 2.7 with itertools, codecs modules;  multiprocessing.pool, multiprocessing.queue for parallelization; rpy2 for running sequenza-utils from R. 
\end{itemize}

\section{Getting ready with Sequenza package/Installing R/Setting up Sequenza}
\begin{itemize}
\item download from bitbucket/cbs.dtu.dk
\item how to install it. R CMD INSTALL sequenza\_version.tar.gz
\end{itemize}

A typical  workflow by Sequenza is as follow :
\begin{enumerate}
\item Convert pileup to abfreq 
\item GC normalization
\item Obtain depth ratio and B allele frequencies
\item Allele-specific segmentation
\item Infer cellularity and DNA-index by model fitting
\item Segmentation and mutations
\end{enumerate}
\section{Preparing inputs for Sequenza}
In order to obtain precise mutational and aberration patterns in a tumor sample, Sequenza requires a matched normal sample from the same patient. In short, the following files are needed to get started with Sequenza. 
\begin{enumerate}
\item A pileup file from the tumor specimen
\item A pileup file from the normal specimen
\item A FASTA reference genomic sequence file (optional, for GC-content correction)
\end{enumerate}
We recommend using pre-processed and quality filtered BAM files to obtain mpileup calls for both samples. 

Pileup files can be generated using \texttt{samtools} (ref). The genome sequence file can be obtained from (url).
\shellcmd{
samtools mpileup  -f hg19.fasta -Q 20 normal.bam
}
\shellcmd{
samtools mpileup -f hg19.fasta -Q 20 tumor.bam
}

\section{First the non-R part: pre-processing data}

For convenience and efficiency we have implemented pre-processing algorithms in an external (not called from R) Python program. The program is provided with the package; it's exact location can be found like this:

<<label=loadLib, echo=TRUE>>=
system.file("exec", "sequenza-utils.py", package="sequenza")
@

You may wish to copy this program to a location on your path. NOTE: this script requires several UNIX tools and thus probably not work on Windows (HOW ABOUT CYGWIN ?).

IS THE GC CONTENT FILE INDEPENDENT OF REFERENCE GENOME USED FOR ALIGNMENT AND MPILEUP ?
SHOULD NON-CANONICAL CHROMOSOMES BE REMOVED IF ONE WANTS GC CONTENT CALCULATIONS BE DONE ON THEIR REFERENCE GENOME ?

Extract average GC content in 50-base genomic windows:
\shellcmd{
sequenza-utils.py GC-windows -w 50 hg19.fa | gzip > hg19.gc50Base.txt.gz
}

Process the two pileup files to obtain an "abfreq" file containing alleles and mutation frequency.
\shellcmd{
sequenza-utils.py pileup2tab -gc hg19.gc50Base.txt.gz -r 0001-normal\_blood.pileup.gz -s 0001-met2.pileup.gz -q 20 -n 10 -o 0001-met2.abfreq.txt.gz
}

----- UPDATE ME UPDATE ME UPDATE ME UPDATE ME UPDATE ME UPDATE ME -----

\section{Read the pre-processed data (\textit{abfreq} file) into R}


The remainder of this example takes place in R.

Load the sequenza package:
<<label=loadLib, echo=TRUE>>=
library("sequenza")
@

Find the example data file:
<<label=setFile, echo=TRUE>>=
data.file <-  system.file("data", "abf.data.abfreq.txt.gz", package = "sequenza")
data.file
@

The abfreq file can be read all at once, but processing one chromosome at a time is less demanding on computational resources and might be preferable.  (Note that the demo data included with sequenza is only chromosome 1)

Read only the data corresponding to chromosome 1:
<<label=readAfreqChr, echo=TRUE, eval=FALSE>>=
abf.data <- read.abfreq(data.file, chr.name = "1")
@

Alternatively, read all data at once (not run):
<<label=readAfreq, echo=TRUE>>=
abf.data <- read.abfreq(data.file)
@

<<>>==
str(abf.data)
@


\section{Quality control step?  (EXPLAIN)}

Each nucleotide aligned in the sequencing is associate with a quality score. The \textit{sequenza-utils} software is capable of filtering the base with the quality lower then a specified value (default is 20), and returns the rate of reads that have passed the filter in the column \textit{sample.reads.above.quality}, while the \textit{depth.sample} column contains the raw depth calculated in the pileup (from samtools).
The product of the rate of bases that have passed the quality check and the total amount or reads aligned at the same nucleotide return the number of reads that have passed the quality check.

<<label=goodReads, echo=TRUE>>=
abf.data$good.s.reads <- abf.data$depth.sample * 
                         abf.data$sample.reads.above.quality
@

\section{GC-normalization}

The number of reads at a given genomic position can be affected by the local GC content. We attempt to remove this bias as in (ref).

It is possible to gather gc-content information from the entire file (normally this would be the entire genome, but in our example it contains only chromosome 1):
<<label=depthRGCnormall, echo=TRUE, results=hide>>=
gc.stats <- gc.sample.stats(data.file)
@


Or alternatively, it is possible to collect the GC-contents information from an object loaded in the environment.
<<label=depthRGCnorm, echo=TRUE, eval=FALSE>>=
gc.stats <- gc.norm(ratio = abf.data$depth.ratio,
                    gc = abf.data$GC.percent)
@

Calculate the GC-normalized depth ratio:
<<label=useGCmedians, echo=TRUE>>=
gc.vect  <- setNames(gc.stats$raw.mean, gc.stats$gc.values)

abf.data$adjusted.ratio <- abf.data$depth.ratio / 
                           gc.vect[as.character(abf.data$GC.percent)]                       
@


<<fig = TRUE, width = 8, height = 4.5>>==
par(mfrow = c(1,2), cex = 1, las = 1, bty = 'l')
matplot(gc.stats$gc.values, gc.stats$raw,
        type = 'b', col = 1, pch = c(1, 19, 1), lty = c(2, 1, 2),
        xlab = 'GC content (%)', ylab = 'Uncorrected depth ratio')
legend('topright', legend = colnames(gc.stats$raw), pch = c(1, 19, 1))
hist2(abf.data$depth.ratio, abf.data$adjusted.ratio,
      breaks = prettyLog, key = vkey, panel.first = abline(0, 1, lty = 2),
      xlab = 'Uncorrected depth ratio', ylab = 'GC-adjusted depth ratio')
@


\section{Create genomic profiles}

\subsection{First, the depth ratio}

Summarize the depth ratio by binning the data in overlapping genomic windows:
<<label=depthWindowing, echo=TRUE, results=hide>>=
abf.r.win <- windowValues(x = abf.data$adjusted.ratio,
             positions = abf.data$n.base,
             chromosomes = abf.data$chromosome,
             window = 1e6, overlap = 1,
             weight = abf.data$depth.normal)
@

\begin{figure}[H]
      \centering
<<label=plotDepthProfile,fig=TRUE,width=6,height=4>>=

plotWindows(abf.r.win[[1]], log2.plot = FALSE, 
            ylab = "Depth ratio", xlab = "Position (bases)", 
            main = names(abf.r.win)[1], las = 1, n.min = 1, 
            ylim = c(0, 2.5))
@
      \caption{Depth ratio profile visualization over a single chromosome. }
      \label{fig:SingleCNProfview}
\end{figure}


\subsection{Next, the B-allele frequencies}

The column \textit{ref.zygosity} contains the zygosity derived from the germline sample. the possible values are \textit{het} for heterozygous positions and \textit{hom} for homozygous positions.
<<label=HetSepqring, echo=TRUE>>=
abf.hom  <- abf.data$ref.zygosity == 'hom'
abf.het  <- abf.data[!abf.hom, ]
@

Summarize the BAF by binning the data in overlapping genomic windows (including only those positions called heterozygous in the normal sample):
<<label=BAFWindowing, echo=TRUE, results=hide>>=
abf.b.win <- windowValues(x = abf.het$Bf,
             positions = abf.het$n.base,
             chromosomes = abf.het$chromosome,
             window = 1e6, overlap = 1,
             weight = round(x = abf.het$good.s.reads, digits = 0))
@

\begin{figure}[H]
      \centering
<<label=plotBAFProfile,fig=TRUE,width=6,height=4>>=
plotWindows(abf.b.win[[1]], ylim = c(0, 0.5), 
           main = names(abf.r.win)[1], xlab = "Position (bases)",
           ylab = "B allele frequency", n.min = 10)
@
      \caption{B-allele frequency profile visualization over a single chromosome.}
      \label{fig:SingleBAFProfview}
\end{figure}

\section{Allele-specific segmentation}

\subsection{Find genomic breakpoints}

To find breakpoints we use the allele-specific segmentation algorithm from the \textit{copynumber} package \cite{BMCcopynumber}.
<<label=ASCPF, echo=TRUE>>=
breaks <- find.breaks(abf.het, gamma = 80, kmin = 10, baf.thres = c(0, 0.5))
head(breaks)
@

Now obtain the segment values:
<<label=so.segs, echo=TRUE>>=
seg.s1 <- segment.breaks(abf.data, breaks = breaks)
@

\section{Select mutations by mutation frequency}
I the genotype file (the \textit{abfreq} file) the mutation are detected as homozygous position with a decreased frequency of the germline nucleotide. A set of nucleotide not present in the germline is present with the relative frequency in the column \textit{AB.sample}. Being a frequency derived by the number of reads covering the position, the accuracy of the measurement is depending on the depth in the considered position.
In order to filter the mutations the function \textit{mutation.table} allow to filter the present mutation to a define level of frequency, a desired number of reads depth, and a desired number of mutated nucleotide per position. Additionally it is possible to swap the \textit{adjusted.ratio} column with the corresponding value after segmentation.
<<label=doF, echo=TRUE>>=
mut.tab <- mutation.table(abf.data, mufreq.treshold = 0.15, 
                          min.reads = 40, max.mut.types = 1,
                          min.type.freq = 0.9, segments = seg.s1)
@

However it is optional, without providing the segmented data the \textit{adjusted.ratio} would remains unchanged.
<<label=doF, echo=TRUE>>=
mut.tab.no.seg <- mutation.table(abf.data, mufreq.treshold = 0.15, 
                          min.reads = 40, max.mut.types = 1,
                          min.type.freq = 0.9)
@
<<label=doF, echo=TRUE>>=
dim(mut.tab)

head(mut.tab)

head(mut.tab.no.seg)
@

\section{Plot chromosome view with mutations, BAF, depth ratio and segments}

The visualization can be made by chromosome, using binned data and segmented data. Optionally can be inserted the mutations table as in figure \ref{fig:3panelsPlot} and the estimated parameters to draw the resulting model lines as in figure \ref{fig:crhomViewWithCP} 
\begin{figure}[H]
      \centering
<<label=3panelsPlot,fig=TRUE,width=6,height=6>>=

chromosome.view(mut.tab = mut.tab[mut.tab$chromosome == "1",], baf.windows = abf.b.win[[1]], 
                ratio.windows = abf.r.win[[1]], min.N.ratio = 1,
                segments = seg.s1[seg.s1$chromosome == "1",], main = "Chromosome 1")
@ 
      \caption{Plots of Mutation (top), B-allele frequencies (middle) and depth ratio (bottom) for chromosome position.}
      \label{fig:3panelsPlot}
\end{figure}


\section{Inference of cellularity and DNA-index}

The parameter estimation is performed on the segmented data, using BAF and depth ratio information.
In order to avoid to catch errors due to the heterogeneity of the sample, we can filter the segments smaller then a certain amount. For instance, we can be confident that segments bigger then few megabases have enough data points to usually insure a correct measure. Alternatively it could be possible to exclude chromosomal regions usually know to be problematic, as the region close to the telomeres and also near the centromere 
<<label=filterSegs, echo=TRUE>>=
seg.filtered <- seg.s1[(seg.s1$end.pos - seg.s1$start.pos) > 10e6, ]
@

Every segment is evaluated against the model lines using the resulting density of a binomial distribution and the possible values of the model. In order to perform every segment needs to be associate with a sample size, to generate the distribution function. For practical reason the sample size can not be in the order of the size of the segment in nucleotide (millions), So we use the size of the segment in megabases, added to an arbitrary offset (eg 150), to allow each segment to generate a proper distribution.
<<label=segsWeight, echo=TRUE>>=
weights.seg  <- 150 + round((seg.filtered$end.pos - seg.filtered$start.pos) / 1e6, 0)
@

The genome wide average depth ratio, should be a value close to 1, after normalization. However, since in this example we only consider chromosome 1, we have a different value (I will add one or more chr to make the avg became 1...). 
<<label=avg.depth.ratio>>=
avg.depth.ratio <- mean(gc.stats$adj[,2])
avg.depth.ratio
@

The function \textit{baf.model.fit} evaluate the segmented data to a set of selected value of cellularity and DNA index. Using the implemented model to calculate the theoretic points it returning an x,y,z list containing a matrix z whit the log likelihood for the combinations of the two parameters, a vector x containing all the evaluated DNA index values and a vector y containing all the evaluated cellularity value.
<<label=BAFmodelFIT, echo=TRUE, results=hide>>=
CP <- baf.model.fit(Bf = seg.filtered$Bf, depth.ratio = seg.filtered$depth.ratio, 
                    weight.ratio = weights.seg,
                    weight.Bf = weights.seg,
                    avg.depth.ratio = avg.depth.ratio,
                    cellularity = seq(0.1,1,0.01), 
                    dna.index = seq(0.5,3,0.05), mc.cores = 4)                   
@

It is possible to calculate the confidence intervals for the two parameters using the function \textit{get.ci}

<<label=ConfIntCP, echo=TRUE>>=
cint <- get.ci(CP)
@

As well it is possible to plot the likelihood over the combination of the two parameters, highlighting the point estimate and lines delimiting the confidence region.
\begin{figure}[H]
      \centering
<<label=CPplot,fig=TRUE,width=6,height=6>>=
cp.plot(CP)
cp.plot.contours(CP, add = TRUE, likThresh = c(0.5, 0.75, 0.95, 0.99))
@ 
      \caption{Result from the Bayesian inference over the defined range of cellularity and DNA-index. The color indicates the log-likelihood of the corresponding cellularity/DNA-index values.}
      \label{fig:cpPlot}
\end{figure}


Alternatively it is possible to draw the likelihood distribution for each parameter, using the information retrieved by the \textit{get.ci} function.
\begin{figure}[H]
      \centering
<<label=CPplotCI,fig=TRUE,width=6,height=6>>=
par(mfrow = c(2,2))
cp.plot(CP)
plot(cint$values.y, ylab = "Cellularity",
     xlab = "likelihood", type = "n")
select <- cint$confint.y[1] <= cint$values.y[,2] & cint$values.y[,2] <= cint$confint.y[2]
polygon(y = c(cint$confint.y[1], cint$values.y[select, 2], cint$confint.y[2]), 
        x = c(0, cint$values.y[select, 1], 0), col='red', border=NA)
lines(cint$values.y)
abline(h = cint$max.y, lty = 2, lwd = 0.5)  

plot(cint$values.x, xlab = "DNA index",
     ylab = "likelihood", type = "n")
select <- cint$confint.x[1] <= cint$values.x[,1] & cint$values.x[,1] <= cint$confint.x[2]
polygon(x = c(cint$confint.x[1], cint$values.x[select, 1], cint$confint.x[2]), 
        y = c(0, cint$values.x[select, 2], 0), col='red', border=NA)
lines(cint$values.x)
abline(v = cint$max.x, lty = 2, lwd = 0.5)

@ 
      \caption{Plot of the log likelihood with respective cellularity and DNA-index probability distribution and confidence intervals.}
      \label{fig:cpPlotCI}
\end{figure}

\section{Call CNVs and mutations using the estimated parameters}

<<label=seParam, eval=TRUE>>=
cellularity <- cint$max.y
cellularity
dna.index <- cint$max.x
dna.index
@

\subsection{Detect mutated alleles}

<<label=mmufBayes, eval=TRUE>>=
mut.tab.clean <- na.exclude(mut.tab)
mut.alleles <- mufreq.bayes(mufreq = mut.tab.clean$F, depth.ratio = mut.tab.clean$adjusted.ratio,
                            cellularity = cellularity, dna.index = dna.index,
                            avg.depth.ratio = 1)

head(mut.alleles)
head(cbind(mut.tab.clean[,c("chromosome","n.base","F","adjusted.ratio", "mutation")], mut.alleles))
@

\subsection{Detect Copy number variation}

<<label=bafBayes, eval=TRUE>>=
cn.alleles <- baf.bayes(Bf = seg.s1$Bf, depth.ratio = seg.s1$depth.ratio,
                        cellularity = cellularity, dna.index = dna.index,
                        avg.depth.ratio = 1)

seg.s1.cn <- cbind(seg.s1, cn.alleles)
head(seg.s1.cn)
@

\section{Visualize detected copy number}

\begin{figure}[H]
      \centering
<<label=chrViewWithCP,fig=TRUE,width=6,height=6>>=

chromosome.view(mut.tab = mut.tab[mut.tab$chromosome == "1",], baf.windows = abf.b.win[[1]], 
                ratio.windows = abf.r.win[[1]],  min.N.ratio = 1,
                segments = seg.s1.cn[seg.s1.cn$chromosome == "1",], main = "Chromosome 1",
                cellularity = cellularity, dna.index = dna.index,
                avg.depth.ratio = 1)
@ 
      \caption{Plots of Mutation (top), B-allele frequencies (middle) and depth ratio (bottom) for chromosome position. Horizontal dotted line indicate different copy number/allelic state. }
      \label{fig:crhomViewWithCP}
\end{figure}

%\newpage
\begin{figure}[H]
      \centering
<<label=chrView17WithCP,fig=TRUE,width=6,height=6>>=

chromosome.view(mut.tab = mut.tab[mut.tab$chromosome == "17",], baf.windows = abf.b.win[[17]], 
                ratio.windows = abf.r.win[[17]],  min.N.ratio = 1,
                segments = seg.s1.cn[seg.s1.cn$chromosome == "17",], main = "Chromosome 17",
                cellularity = cellularity, dna.index = dna.index,
                avg.depth.ratio = 1)
@ 
      \caption{Plots of Mutation (top), B-allele frequencies (middle) and depth ratio (bottom) for chromosome position. Horizontal dotted line indicate different copy number/allelic state. }
      \label{fig:crhomView17WithCP}
\end{figure}


%%%% bibliography
\bibliographystyle{plain}
\bibliography{sequenza}

\end{document}

                